%!TEX root = ../thesis-main.tex
\chapter{Panoramica}\label{chap:introduction}
\section{Introduzione}\label{sec:background}
Le \ac{API} rappresentano una componente fondamentale nei sistemi software moderni. Da decenni, esse sono state il cardine dell'interoperabilità tra differenti software e piattaforme, permettendo la
creazione di ecosistemi software integrati e coesi, in cui applicazioni di diversa natura possono scambiare dati e funzionalità in modo efficace ed efficiente.
Nell'architettura di un sistema software, le \ac{API} fungono da interfacce contrattuali definendo i metodi e i protocolli con cui le diverse componenti software interagiscono. Questo non solo 
promuove la modularità e il riuso, ma anche la scalabilità dell'intero sistema; in particolare con l'evoluzione delle architetture distribuite il ruolo delle \ac{API} è ancora più cruciale.
Esse non solo consentono la comunicazione tra diversi servizi, ma spesso rappresentano il principale punto di contatto e di interazione tra un servizio e i suoi consumatori, sia essi altre applicazioni
o utenti finali.

In questo scenario si pone il progetto discusso nel presente documento: l'analisi e l'implementazione di un architettura software che interagisce con il simulatore Alchemist, esponendo funzionalità e
servizi di controllo essenziali per lo sviluppo di applicativi attraverso le API progettate.
Attraverso questo nuovo modulo, si mira a fornire un accesso standardizzato ed efficiente alle componenti di un sistema software complesso come Alchemist, facilitando così la manipolazione e il controllo
delle sue funzionalità.

\section{Contesto}\label{sec:context}
\subsection{Simulazione}\label{ssec:alchemist}
Alchemist~\cite{alchemist} è un simulatore stocastico general-purpose, estensibile ed open-source sviluppato dall'Università di Bologna. Permette la simulazione di scenari relativi al
\textit{pervasive}, \textit{aggregate} e \textit{nature-inspired computing}.

\paragraph{Meta-modello} Gli elementi principali che compongono Alchemist sono\footnote{https://alchemistsimulator.github.io/}:
\begin{itemize}
    \item \textbf{Molecule}: denominazione assegnata ad un dato specifico.
    \item \textbf{Concentration}: il valore assegnato ad una particolare molecola.
    \item \textbf{Node}: contenitore al cui interno risiedono molecole e reazioni, contenuto a sua volta nell'ambiente.
    \item \textbf{Environment}: astrazione del concetto di spazio all'interno di Alchemist. Contiene tutti i nodi ed è in grado di comunicare:
        \begin{enumerate}
            \item La posizione nello spazio dei nodi.
            \item La distanza tra due nodi.
            \item Muovere all'interno dello spazio i nodi.
        \end{enumerate}
    \item \textbf{Linking Rule}: funzione dello stato attuale dell'ambiente che associa ogni nodo ad un vicinato.
    \item \textbf{Neighborhood}: entità composta da un nodo (centro) e un insieme di altri nodi (vicini).
    \item \textbf{Reaction}: rappresenta ogni evento che può cambiare lo stato dell'ambiente. È definita da un insieme, potenzialmente vuoto di condizioni, una o più azioni e una distribuzione temporale.
        La frequenza con cui può accadere dipende da:
        \begin{enumerate}
            \item Un parametro statico di frequenza.
            \item Il valore di ogni condizione.
            \item Una equazione di frequenza, che combina la frequenza statica e il valore delle condizioni, restituendo una ``frequenza istantanea''.
        \end{enumerate}
    \item \textbf{Condition}: funzione che prende in input l'ambiente corrente e restituisce un valore booleano e un numero: se la condizione non è verificata, la reazione associatagli non verrà eseguita.
        Il numero restituito in output può influenzare la velocità della reazione, in base alla reazione e alla sua distribuzione temporale.
    \item \textbf{Action}: modella un cambiamento all'interno dell'ambiente.
\end{itemize}

Il meta-modello di Alchemist pu\aacc{o} essere riassunto nella \Cref{fig:alchemist-metamodel}

%----------------------------------------%
\centerimagesource{figures/alchemist-model.png}{Meta-modello di Alchemist}{alchemist-metamodel}{1}{https://alchemistsimulator.github.io/explanation/metamodel/}
%----------------------------------------%

\paragraph{Incarnation} La chiave dell'estensibilit\aacc{a} di Alchemist risiede nella rappresentazione astratta di molecole e concentrazioni. Anche
\begin{enumerate*}[label=(\roman*)]
    \item un identificatore generico e
    \item un certo dato, di un qualche tipo.
\end{enumerate*}
All'interno di Alchemist una \textit{Incarnation} include una definizione per il tipo delle concentrazioni, un eventuale insieme di specifiche
condizioni, azione e (raramente) un ambiente e reazioni che operano su quei determinati tipi. In altre parole, un'incarnazione \aacc{e} una
istanza concreta del meta-modello di Alchemist.
%
Diverse \textit{Incarnation} possono modellare universi completamente differenti. Allo stato attuale, Alchemist viene distribuito con le seguenti incarnazioni:
\begin{itemize}
    \item \textbf{SAPERE Incarnation}~\cite{sapere}
    \item \textbf{Protelis Incarnation}~\cite{protelis}
    \item \textbf{Biochemistry Incarnation}\footnote{https://alchemistsimulator.github.io/explanation/biochemistry/}
    \item \textbf{SCAFI Incarnation}~\cite{CASADEI2022101248}
\end{itemize}

\subsection{Interazione coi Simulatori}\label{ssec:sim-interactions}
Allo stato attuale, l'interazione con le simulazioni avviene principalmente mediante lo sviluppo di codice all'interno della \ac{JVM} che comunichi direttamente con il modello di Alchemist.
Questo porta allo sviluppo di moduli aggiuntivi coerenti con l'architettura generale del sistema, ma è evidente come la loro implementazione non può astrarre al di la delle interfacce fornite
dal simulatore. Prendendo come esempio il modulo per la realizzazione di un interfaccia grafica, l'intero modulo è a conoscenza e deve adattarsi al dominio applicativo, implicandone 
la profonda conoscenza e comprensione dell'interazione di tutte le componenti.

\section{Motivazioni e Obiettivi}\label{sec:motivations-objectives}
Quanto discusso nella sezione precedente mette in luce come risulti di grande aiuto il controllo e la gestione dell'intero simulatore attraverso interfacce ad alto livello che astraggano dalla simulazione
e le sue relazioni interne.

\subsection{Interazione Efficiente tra Piattaforme Diverse}\label{ssec:platforms-interactions}
Mediante lo sviluppo di API al di sopra del modello di Alchemist, è possibile costruire meccanismi che permettano di interagire con le simulazioni in modo standardizzato per qualsiasi piattaforma che
ne richieda i servizi. In particolare, questo provvede a definire due tipi di standardizzazione: una dal punto di vista delle interfacce contrattuali esposte dalle API, perciò valide all'interno
di un qualsiasi sistema software (e.g. sistema \textit{web-based} all'infuori della \ac{JVM}), e un'altra per quanto riguarda
le strategie impiegate per il recupero dei dati necessari o l'invio di comunicazioni alle componenti interne. Proprio grazie ad un buon design di queste ultime, si può provvedere ad esporre metodologie
di accesso o controllo della simulazione nella maniera più efficiente e personalizzabile possibile.

\subsection{Obiettivi}\label{ssec:objectives}
Obiettivo principale di questo lavoro è quello di progettare e implementare un'architettura software in grado di accedere alle componenti del simulatore Alchemist, e rendere disponibili all'esterno
servizi e funzionalità di quest'ultimo, attraverso un'insieme di API standardizzate ed efficienti, compatibili con sistemi potenzialmente all'infuori della \ac{JVM}. In questo modo, si fornisce un
sistema di accesso e controllo efficiente delle simulazioni eseguite all'interno di Alchemist, in grado di porsi come canale comunicativo tra applicativi software terzi e il simulatore stesso.

In generale il software prodotto deve focalizzarsi sulla produzione di un architettura generica ed estendibile in grado di adattarsi alla natura mutevole di Alchemist, fornendo allo stesso tempo
un punto d'accesso consistente, flessibile ed efficiente.
